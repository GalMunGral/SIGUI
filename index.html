<head>
  <meta name="viewport" content="initial-scale=1, user-scalable=no" />
  <link
    href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400..800;1,400..800&display=swap"
    rel="stylesheet"
  />

  <style>
    body {
      max-width: 640px;
      padding: 40px;
      margin: auto;
      overflow-x: hidden;
      font-family: "EB Garamond", serif;
      font-size: 20px;
      padding-bottom: 200px;
    }

    code {
      font-size: 0.75em;
    }

    h1,
    h2,
    h3 {
      text-align: center;
      font-style: italic;
    }

    input {
      width: 200px;
    }

    input[type="number"] {
      width: 50px;
      margin-right: 10px;
    }

    label {
      color: gray;
      font-size: 0.75em;
    }

    input[type="file"] {
      width: 200px;
    }

    a {
      color: black;
    }

    pre {
      overflow: scroll;
    }

    canvas {
      user-select: none;
      display: block;
      width: 100%;
      height: 200px;
      box-shadow: 0 0 5px lightgray;
      margin: 20px auto;
      touch-action: none;
    }

    #gpu {
      box-shadow: none;
      height: 120px;
    }

    #glass {
      width: 600px;
      height: 400px;
    }

    blockquote pre {
      font-family: Courier, monospace;
      font-size: 16px;
    }
  </style>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script
    async
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"
  ></script>
</head>

<body>
  <h1>
    Structure and Interpretation<br />
    of Graphical User Interfaces
  </h1>
  <h2>(Rough Draft)</h2>

  <p>
    Most people well-versed in science and technology can give you a general
    account of the natural world, from galaxies to electrons and protons, but
    the same cannot be said for man-made systems as simple as graphical user
    interfaces (GUIs). It's quite unfortunate how little we know about the
    things that our own species is creating!
  </p>
  <p>
    So how do GUIs work? And what is the
    <em>essense</em> of GUIs? This question has been on my mind for many years,
    and only recently have I been able to connect the dots. In this article,
    I'll try to weave together the pieces that I've collected over the years, in
    the hopes that it'll bring the same enlightenment to like-minded seekers.
  </p>

  <h2>Event Loop</h2>

  <p>First, each user interface is driven by an event loop, which is simply:</p>

  <blockquote>
    <pre>
  while !quit {
    if event = poll() {
      handle(event)
    }
    if dirty { 
      draw()
    }
  }</pre
    >
  </blockquote>
  <p>
    These are the two spells that conjure the ghosts behind the sheet of pixels:
  </p>
  <blockquote>
    <pre>
fn draw() {
  for (x,y) in shape {
    color(x, y)
  }
}

fn handle(event) {
  target = pick(event.x, event.y)
  target.handle(e)
}</pre
    >
  </blockquote>
  <p>
    Try clicking on this canvas. Can you spot the ghosts emerging out of the
    noise?
  </p>

  <div style="position: relative">
    <canvas id="raster"></canvas>
  </div>
  <script type="module" src="./demo/raster.js"></script>

  <h2>Polygons</h2>
  <p>We all know how to draw a rectangle with a simple nested loop:</p>
  <blockquote>
    <pre>
for y in y1...y2 {
  for x in x1...x2 {
    color(x, y)
  }
} </pre
    >
  </blockquote>
  <p>
    This idea can be extended to all closed shapes, except that for each \(y\)
    the horizontal scan line could now enter and leave the shape any number of
    times. Suppose it crosses the boundary at \(x_1, x_2, ...x_n\). It can be
    proved that that \(n\) must be even, so all we need to do is to traverse the
    intervals \([x_1, x_2)\), \([x_3, x_4)\), etc.:
  </p>
  <blockquote>
    <pre>
for y in y1...y2 {
  for (x1, x2) in intervals(y) {
    for x in x1...x2 {
      color(x, y)
    }
  }
}</pre
    >
  </blockquote>
  <p>
    This algorithm could also be adapted to check if the point at integer
    coordinates \((x,y)\) lies within a closed shape. If it does, \(x\) must be
    on one of those intervals, and therefore there must be an odd number of
    intersections on the either side &mdash; this is all we need for a hit-test:
  </p>
  <blockquote>
    <em>
      Given a point \((x_p,y_p)\), count the number of times the scan line \(y =
      y_p\) intersects the curve at a \(x > x_p\). The point is on the inside if
      and only if the number is odd.
    </em>
  </blockquote>
  Now, how exactly do we find those intersection points? To answer the
  question...

  <h2>Rasterization</h2>

  <p>
    ... we first need to approximate arbitrary curves with polygons. With
    polygons, we can just focus on the straight edges that straddle the
    horizontal scan line. Suppose an edge has two endpoints \((x_1,y_1)\)
    (inclusive) and \((x_2, y_2)\) (exclusive), where \(y_1 < y_2\). An
    intersection point exists if and only if \(y_1 \leq y < y_2\). We can easily
    obtain the intersection point $$intersection=\left(x_1 +
    \frac{x_2-x_1}{y_2-y_1}(y-y_1), y\right).$$ The slope of line segment
    $$k=\frac{\Delta x}{\Delta y}=\frac{x_2-x_1}{y_2-y_1}$$ tells us the how
    much \(x\) changes when we increment \(y\). Using the slope we can walk
    along the line segment &mdash; the point after \((x,y)\) is simply \((x+k,
    y+1)\). Here is the scan-line rasterization algorithm:
  </p>
  <blockquote>
    <em
      >Keep track of a set of edges that currently intersect the scan line,
      along with with their respective intersection points. In each iteration:
      <ol>
        <li>Traverse each horizontal interval at current \(y\).</li>
        <li>Increment \(y\), then</li>
        <ul>
          <li>Discard edges that no longer intersect the scan line.</li>
          <li>Increment each remaining intersection point by \((k, 1)\).</li>
          <li>Add new edges that start to intersect the scan line.</li>
        </ul>
      </ol>
    </em>
  </blockquote>
  <p>
    The canvas below will draw a polygon from the points you click on (you need
    to pick at least 3) using this algorithm (implemented in JavaScript). The
    polygon will be highlighted when you hover over it.
  </p>

  <canvas id="polygon"></canvas>
  <script type="module" src="./demo/polygon.js"></script>
  <p>Congratulations! You now understand <em>everything</em> about GUIs!</p>
  <p>But let's continue...</p>
  <h2>Transforms</h2>
  <p>
    To move and morph our polygon, we can apply linear transformations. Since a
    polygon is defined by its vertices, the only thing we need to do is to apply
    the same transformation to each vertex before we rasterize the polygon.
  </p>
  <p>
    Mathematically, it's more convenient to use homogeneous coordinates \((x, y,
    1)\) to represent the point \((x,y)\) on screen, because then translation,
    rotation and scaling can all be expressed neatly as composable \(3\times3\)
    matrices: $$T_{x,y} = \begin{pmatrix} 1 & 0 & x \\ 0 & 1 & y \\ 0 & 0 & 1
    \end{pmatrix}, R_{\theta} = \begin{pmatrix} \cos\theta & -\sin\theta & 0 \\
    \sin\theta & \cos\theta & 0 \\ 0 & 0 & 1 \end{pmatrix}, S_{c} =
    \begin{pmatrix} c & 0 & 0 \\ 0 & c & 0 \\ 0 & 0 & 1 \end{pmatrix}$$ Try
    dragging the square below to see some of these transforms in action.
  </p>

  <canvas id="transform"></canvas>
  <script type="module" src="./demo/transform.js"></script>

  <h2>Curves</h2>
  <p>
    By taking dicrete samples \(p_1, p_2, ...p_N\) along a curve, we can turn
    any shape into an approximating polygon. The magic happens when the sampling
    becomes so fine-grained that the edges become subpixel.
  </p>
  <p>
    Let's take elliptic arcs as an eample. Suppose we want an arc from angle
    \(\phi_1\) to \(\phi_2\) on a ellipse with semi-major axis \(a\) and
    semi-minor axis \(b\), centered at \((x,y)\), and rotated by an angle
    \(\theta\). We can create a polyon with \(N + 1\) points from the curve,
    using this formula: $$\begin{pmatrix}x_i\\y_i\end{pmatrix} = T_{x,y} \cdot
    R_{\theta} \cdot \left(a\cos\left(\phi_1 + i \cdot\frac{\phi_2 -
    \phi_1}{N}\right), b\sin\left(\phi_1 + i\cdot\frac{\phi_2 -
    \phi_1}{N}\right)\right)^\top$$ Try increasing \(N\) and observe how the
    coutour turns into a smooth curve.
  </p>

  <canvas id="ellipse"></canvas>
  <div>
    <label>\(N\)</label>
    <input id="ellipse-n" type="number" value="8" min="3" />
    <label>\(a\)</label> <input id="ellipse-a" type="number" value="150" />
    <label>\(b\)</label> <input id="ellipse-b" type="number" value="150" />
    <label>\(\theta\)</label>
    <input id="ellipse-theta" type="number" value="0" />
    <label>\(\phi_1\)</label>
    <input id="ellipse-phi-1" type="number" value="15" />
    <label>\(\phi_2\)</label>
    <input id="ellipse-phi-2" type="number" value="345" />
  </div>
  <script type="module" src="./demo/ellipse.js"></script>

  <p>
    Ellipses are important because they actually help us draw curves that are
    more than a single pixel wide, which can be approximated by a sequence of
    skinny rectangles connected using circles as "elbows". Try clicking on the
    canvas below to draw a polyline. Can you spot the circles and rectangles?
  </p>

  <canvas id="curve"></canvas>
  <div>
    <label>line width </label>
    <input id="line-width" type="number" min="1" value="4" />
  </div>
  <script type="module" src="demo/curve.js"></script>

  <p></p>

  <h2>Interpolation</h2>

  <p>
    So far all of our polygons are black, which is quite boring. We can make
    them prettier by linearly interpolate between two colors. Linear
    interpolation between two values \(v_1\) and \(v_2\) just means the weighted
    average $$interpolate(v_1, v_2, t) = (1-t) \cdot v_1 + t \cdot v_2$$ where
    the parameter \(t \in [0,1]\) controls how far we are from the starting
    point. It should be easy to see that as \(t\) goes from \(0\) to \(1\), the
    interpolated value changes continuously from \(v_1\) to \(v_2\). For color
    gradients, \(t\) could be based on distance. Take a look at the two types of
    color gradients below, computed as follows: $$RadialGradient(x,y) =
    interpolate\left(C_1, C_2, \frac{\sqrt{(x-x_o)^2 + (y-y_o)^2}}{r}\right)$$
    $$LinearGradient(x,y) = interpolate\left(C_1, C_2, \frac{y -
    y_{min}}{y_{max} - y_{min}}\right)$$
  </p>

  <canvas id="gradient"></canvas>
  <div>
    <input id="gradient-color-1" type="color" value="#eeeeee" />
    <input id="gradient-color-2" type="color" value="#000000" />
  </div>
  <script type="module" src="./demo/gradient.js"></script>

  <h2>Bézier</h2>

  <p>
    We've seen that interpolating
    <strong>colors</strong> using <strong>position</strong> as the parameter
    gives us color gradients. Now let's take one step further: Interpolating
    <strong>positions</strong> using <strong>time</strong> as the paramter can
    actually gives us smooth curves &mdash; this is the well-known Bézier curve.
  </p>
  <p>
    Bézier curves can be constructed by an iterative process: given control
    points \(p^{(0)}_0, p^{(0)}_1, \dots p^{(0)}_n\), we can find the point
    \(B(t)\) by the following process:
  </p>
  <blockquote>
    <em
      >In each iteration \(k \in [1, n]\), for each \(i \in [0, n - k]\):
      $$p^{(k)}_i = (1-t) \cdot p^{(k-1)}_i + t \cdot p^{(k-1)}_{i+1}$$ Finally,
      \(B(t) := p^{(n)}_0\)</em
    >
  </blockquote>

  <p>
    For linear Bézier curves, we are just traveling from point A to point B at a
    constant speed. Higher-order Bézier curves are not easy to describe, and the
    best way to understand them is to follow this iterative algorithm manually
    on paper and trace out the curve it generates.
  </p>
  <p>
    Try clicking on the canvas below to generate a Bézier curve of any order.
    The color of the moving circle is linearly interpolated using time as the
    parameter.
  </p>

  <canvas id="animation"></canvas>
  <script type="module" src="./demo/animation.js"></script>

  <h2>Text</h2>
  <p>
    To rasterize a region enclosed by Bézier curves, we can apply the same trick
    we used for elliptic arcs &mdash; just sample \(N\) points on the curve at
    \(t = 0, 1/N, 2/N, \dots, 1\) and draw a polygon instead. Try experimenting
    with Bézier shapes below. (After putting down the first point, you need to
    add \(order\) control points for each new "edge", i.e., 2 for quadratic and
    3 for cubic.)
  </p>

  <h4>Quadratic Bézier</h4>
  <canvas id="quadratic-bezier"></canvas>
  <h4>Cubic Bézier</h4>
  <canvas id="cubic-bezier"></canvas>

  <p>
    Why do we care about these weird geometries? Well, every single character on
    this page &mdash; or, indeed, everything that uses OpenType/TrueType fonts
    &mdash; is made of nothing but linear, quadratic and cubic Bézier curves!
    Take a look at the text below &mdash; it's rendered by the exact same
    algorithm that we used earlier to draw our first polygon!
  </p>
  <script type="module" src="./demo/bezier.js"></script>
  <canvas id="font"></canvas>
  <div>
    <label>font (OTF/TTF): </label>
    <input id="font-file" type="file" accept=".otf,.ttf" />
    <label>text </label>
    <input id="font-text" value="Everything is a polygon!" maxlength="30" />
    <label>size </label>
    <input id="font-size" type="number" step="1" value="40" />
  </div>
  <script type="module" src="./demo/font.js"></script>

  <h2>Layers</h2>
  <p>
    Usually, objects on screen form a hierarchy: Shapes contain other shapes,
    and when a containing shape moves, everthing inside moves along with it.
    Naturally, we want to represent the entire GUI as a
    <it>tree</it> of shapes. To render the tree onto the screen we usually need
    to perform a <i>pre-order</i> traversal, because containers are almost
    always placed under the things they contain and therefore need to be drawn
    first.
  </p>
  <blockquote>
    <pre>
fn draw(node) {
  drawGeometry(node)
  for child in node.children {
    draw(child)
  }
}</pre
    >
  </blockquote>
  If we use a layout system that takes constraints as input, we will need to
  perform an extra layout pass first to calculate all the coordinates we need
  for rasterization. On a high level, the layout algorithm might look something
  like:
  <blockquote>
    <pre>
fn layout(node, constraints) {
  curConstraints = add(constraints, node.constraints)
  for child in node.children {
    update(curConstraints, layout(child, curConstraints))
  }
  return calculateGeometry(curConstraints)
}</pre
    >
  </blockquote>
  <p>
    For hit-testing, we need to determine the topmost polygon under the pointer.
    The algorithm is pretty straighforward:
  </p>
  <blockquote>
    <em>
      Record polygons in the order they are drawn. To detect a hit, search
      backwards through the list for the last drawn (i.e. topmost) polygon that
      contains the cursor position.
    </em>
  </blockquote>
  <p>
    Now you know how to roll your own <code>&lt;buton/&gt;</code>'s and
    <code>&lt;div/&gt;</code>'s!
  </p>

  <canvas id="recursion"></canvas>
  <div>
    <label>height </label>
    <input id="button-height" type="number" min="0" max="100" />
    <label>width </label>
    <input id="button-width" type="number" min="0" max="300" />
    <label>border radius </label>
    <input id="button-radius" type="number" min="0" max="100" />
  </div>
  <script type="module" src="./demo/composition.js"></script>

  <h2>Compositing</h2>

  <p>
    What if we want to make the layers transparent? This is where the A (<em
      >alpha channel</em
    >) in RGBA and <em>alpha blending</em> comes in. One the ways to blend two
    colors is to use the so-called "over" operator, which simply takes a
    weighted average of the two colors based on their respective contributions
    to the final alpha: $$ a = a_1 + a_2 (1-a_1)$$ $$(r,g,b) =
    \frac{a_1}{a}(r_1,g_1,b_1) + \frac{a_2(1-a_1)}{a}(r_2,g_2,b_2)$$
  </p>
  <canvas id="alpha-compositing"></canvas>
  <div>
    <label>alpha </label>
    <input id="alpha" type="number" min="0.1" max="1" value="0.2" step="0.1" />
  </div>
  <script type="module" src="./demo/alpha.js"></script>

  <h2>Filtering</h2>
  <p>
    To stack transparent layers on top of each other, we need more than just
    blending, otherwise it'd be hard to tell which layer is on top. One solution
    is the "frosted glass" effect. For this, we need to "convolve" the image
    with a Gaussian "kernel" &mdash; this is the well-known Gaussian blur
    filter. What this convolution operation does, simply put, is averaging the
    neighborhood surrounding each pixel, weighted by the 2D Gaussian function:
    $$G(x,y) =
    \frac{1}{2\pi\sigma^2}\exp\left(-\frac{x^2+y^2}{2\sigma^2}\right)$$
    Convolution here is defined as: $$Output(x,y) = \frac{1}{C}\sum_{u=-k}^{k}
    \sum_{v=-k}^{k} G(u,v)Input(x-u, y-v)$$ $$C = \sum_{u=-k}^{k}
    \sum_{v=-k}^{k}G(u,v)$$
  </p>
  <p>
    Try dragging the lens across the image below to see the blur filter in
    action.
  </p>

  <canvas id="glass"></canvas>
  <div>
    <label>sigma </label>
    <input id="sigma" type="number" min="1" max="8" value="5" step="1" />
  </div>
  <script type="module" src="./demo/glass.js"></script>

  <h2>Acceleration</h2>
  <p>
    So far, we have been constantly iterating through all pixels in CPU, which
    could potentially be quite slow for HiDPI screens. Fortunately, we can
    actually process all pixels
    <em>in parallel</em> (for compositing and filtering, at least) &mdash; GPU
    to the rescue!
  </p>

  <canvas id="gpu"></canvas>
  <script type="module" src="./demo/gpu.js"></script>

  <p>
    <a href="https://github.com/GalMunGral/polyrender">(To be continued...)</a>
  </p>
</body>
