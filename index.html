<head>
  <meta name="viewport" content="initial-scale=1, user-scalable=no" />
  <link
    href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400..800;1,400..800&display=swap"
    rel="stylesheet"
  />

  <style>
    body {
      max-width: 640px;
      padding: 40px;
      margin: auto;
      overflow-x: hidden;
      font-family: "EB Garamond", serif;
      font-size: 20px;
      padding-bottom: 200px;
    }

    code {
      font-size: 0.75em;
    }

    h1,
    h2,
    h3,
    h4 {
      text-align: center;
      font-style: italic;
    }

    h2,
    h3 {
      font-weight: normal;
    }

    h2 {
      margin-top: 50px;
    }

    input {
      width: 200px;
    }

    input[type="number"] {
      width: 50px;
      margin-right: 10px;
    }

    label {
      color: gray;
      font-size: 0.75em;
    }

    input[type="file"] {
      width: 200px;
    }

    a {
      color: black;
    }

    pre {
      overflow: scroll;
    }

    canvas {
      user-select: none;
      display: block;
      width: 100%;
      height: 200px;
      box-shadow: 0 0 5px lightgray;
      margin: 20px auto;
      touch-action: none;
    }

    #gpu {
      box-shadow: none;
      height: 120px;
    }

    #glass {
      width: 600px;
      height: 400px;
    }

    blockquote pre {
      font-family: Courier, monospace;
      font-size: 16px;
    }
  </style>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script
    async
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"
  ></script>
</head>

<body>
  <h1>
    Structure and Interpretation<br />
    of Graphical User Interfaces <br />
  </h1>
  <h3>(What I Wish I Had Learned in CS 101)</h3>

  <p>
    How do graphical user interfaces operate at the level of primitive
    operations (i.e. bytes and instructions)? How exactly does a computer, as
    its name suggests,
    <em>compute</em> a vector-based GUI into existence from thin air? How can
    vivid visual metaphors arise algorithmically solely from boring arithmetic
    and logical manipulations?
  </p>
  <p>
    This incomplete article is my first attempt to consolidate the pieces of
    knowledge I've gathered into a concise and coherent answer to these
    questions. In writing and sharing this article, my hope is to shed light on
    this slightly obscure area and spare the curious reader the frustration from
    futile Googling. (ChatGPT, however, seems to be very knowledgeable about
    everything mentioned here.)
  </p>

  <h2>Event Loop</h2>

  <p>First of all, the interactivity of GUIs comes its event loop:</p>

  <blockquote>
    <pre>
while !quit {
  if event = poll() {
    handle(event)
  }
  if dirty { 
    draw()
  }
}</pre
    >
  </blockquote>
  In each iteration, the program processes inputs and produces outputs:
  <blockquote>
    <pre>
fn handle(event) {
  target = pick(event.xy)
  target.handle(event)
}

fn draw() {
  for each geometry on screen {
    for x, y in geometry {
      geometry.color(x, y)
    }
  }
}</pre
    >
  </blockquote>
  <p>
    The main complexity lies in the <code>draw()</code> and
    <code>pick(event.xy)</code> functions. As we'll see, by implementing
    <code>draw()</code>, we'll get a solution for
    <code>pick(event.xy)</code> almost for free.
  </p>

  <h2>Closed Curves</h2>
  <p>
    At the core of 2D graphics is the mathematical concept of
    <em>"the interior of closed curves"</em>, such as circles and rectangles. We
    know how to fill the interior of a rectangle with a simple nested loop:
  </p>
  <blockquote>
    <pre>
fn fill(rect) {
  for y in rect.y1...rect.y2 {
    for x in rect.x1...rect.x2 {
      rect.color(x, y)
    }
  } 
}
</pre
    >
  </blockquote>
  <p>
    This idea can be generalized to all closed curves, except that for each
    \(y\) the horizontal scan line could now enter and leave its interior any
    number of times. Suppose it crosses the curve at \(x_1, x_2, ...x_n\). It
    can be proved that \(n\) must be even, so all we need to do is to fill the
    intervals \([x_1, x_2), [x_3, x_4), \dots, [x_{n-1}, x_n)\). In other words,
  </p>
  <blockquote>
    <pre>
fn fill(curve) {
  for y in curve.y1...curve.y2 {
    for x1, x2 in curve.intervals(y) {
      for x in x1...x2 {
        curve.color(x, y)
      }
    }
  }
}
</pre
    >
  </blockquote>
  <p>
    Using the same logic, we can check if a point at integer coordinates
    \((x,y)\) lies in the interior. If it does, \(x\) must be in the middle of
    some interval in <code>curve.intervals(y)</code>, and therefore there must
    be an odd number of intersections on either side &mdash; this is all we need
    for a hit-test!
  </p>
  <blockquote>
    <em>
      Given a point \((x_p,y_p)\), count the number of times the scan line \(y =
      y_p\) intersects the curve at a \(x > x_p\) (or equivalently, \(x \leq
      x_p\)). The point is on the interior if and only if the number is odd.
    </em>
  </blockquote>
  Now the question is: How do we find <code>curve.intervals(y)</code>?

  <h2>Polygons</h2>

  <p>
    As a starting point, let's look at a simple case: polygons. With polygons,
    our task becomes finding line segments that cross the scan line at \(y\).
    Suppose a line segment has two endpoints \((x_1,y_1)\) (inclusive) and
    \((x_2, y_2)\) (exclusive), where \(y_1 < y_2\). We know a scan line \(y\)
    can only cross the line segment if \(y_1 \leq y < y_2\), and also
    $$intersection=\left(x_1 + \frac{x_2-x_1}{y_2-y_1}(y-y_1), y\right).$$ The
    slope of line segment $$k=\frac{x_2-x_1}{y_2-y_1}$$ tells us the how much
    \(x\) changes when we increment \(y\). Using the slope we can walk the line
    segment: \((x,y), (x+k, y+1), (x + 2k, y+2), \dots\)
  </p>
  <p>Here is the scan-line rasterization algorithm:</p>
  <blockquote>
    <em
      >Keep track of the set of edges that intersect the scan line along with
      their respective intersection points. In each iteration:
      <ol>
        <li>Traverse each interval at current \(y\) and color each pixel.</li>
        <li>Increment \(y\), then</li>
        <ul>
          <li>Discard edges that no longer intersect the scan line.</li>
          <li>Increment each remaining intersection point by \((k, 1)\).</li>
          <li>Add new edges that begin to intersect the scan line.</li>
        </ul>
      </ol>
    </em>
  </blockquote>
  <p>
    The canvas below will draw a polygon from the points you click on, using a
    JavaScript implementation of this algorithm. (You must pick at least 3
    points to draw a polygon!) The polygon will light up in red when you hover
    over it.
  </p>

  <canvas id="polygon"></canvas>
  <script type="module" src="./demo/polygon.js"></script>

  <h2>Transforms</h2>
  <p>
    To move and morph our polygon, we need to apply linear transformations.
    Since a polygon is defined by its vertices, we just need to apply the same
    transformations to each vertex before we rasterize.
  </p>
  <p>
    Mathematically, it's conventional and more convenient to use homogeneous
    coordinates \((wx, wy, w) \in \mathbb{RP}^2\) in projective space to
    represent a point \((x,y) \in \mathbb{R}^2 \) &mdash; this is how CSS
    <code>transform</code> works under the hood&mdash; because it turns
    translation, rotation and scaling all into composable \(3\times3\) matrices:
    $$T_{x,y} = \begin{pmatrix} 1 & 0 & x \\ 0 & 1 & y \\ 0 & 0 & 1
    \end{pmatrix},\ R_{\theta} = \begin{pmatrix} \cos\theta & -\sin\theta & 0 \\
    \sin\theta & \cos\theta & 0 \\ 0 & 0 & 1 \end{pmatrix},\ S_{c} =
    \begin{pmatrix} c & 0 & 0 \\ 0 & c & 0 \\ 0 & 0 & 1 \end{pmatrix}$$ Try
    dragging the square below to see composed transforms in action:
  </p>

  <canvas id="transform"></canvas>
  <script type="module" src="./demo/transform.js"></script>

  <h2>Discretization</h2>
  <p>
    Back to the question of finding <code>curve.intervals(y)</code> for any
    parametric curves. Now that we've covered the case of polygons, there is a
    simple solution: Just convert the curve into a polygon by discrete sampling!
    When the sampling rate becomes so fine-grained that the resulting line
    segments are subpixel, a polygon would be indistinguishable from a smooth
    curve.
  </p>
  <p>
    Let's take elliptic arcs as a concrete eample. Suppose we want to draw an
    arc from angle \(\phi_1\) to \(\phi_2\) on a ellipse centered at \((x,y)\)
    with semi-major axis \(a\) and semi-minor axis \(b\) and rotated by an angle
    \(\theta\). We can sample \(N + 1\) points using the formula:
    $$\begin{pmatrix}x_i\\y_i\end{pmatrix} = T_{x,y} \cdot R_{\theta} \cdot
    \left(a\cos\left(\phi_1 + i \cdot\frac{\phi_2 - \phi_1}{N}\right),
    b\sin\left(\phi_1 + i\cdot\frac{\phi_2 - \phi_1}{N}\right)\right)^\top$$
  </p>
  <p>
    Try increasing \(N\) below to see how the polygon turns into a smooth curve.
  </p>

  <canvas id="ellipse"></canvas>
  <div>
    <label>\(N\)</label>
    <input id="ellipse-n" type="number" value="8" min="3" />
    <label>\(a\)</label> <input id="ellipse-a" type="number" value="150" />
    <label>\(b\)</label> <input id="ellipse-b" type="number" value="150" />
    <label>\(\theta\)</label>
    <input id="ellipse-theta" type="number" value="0" />
    <label>\(\phi_1\)</label>
    <input id="ellipse-phi-1" type="number" value="15" />
    <label>\(\phi_2\)</label>
    <input id="ellipse-phi-2" type="number" value="345" />
  </div>
  <script type="module" src="./demo/ellipse.js"></script>

  <h2>Strokes</h2>
  <p>
    Why such a convoluted example? Well, ellipses are not just interesting in
    their own right. We can use them to render 1D (okay, not really) objects!
    How? Well, we can stroking a thick curve simply by filling a sequences of
    skinny rectangles joined by circles, which are, of course, a special case of
    ellipses! Try drawing on the canvas below. Have you noticed the circles and
    rectangles? What about when you increase the stroke width?
  </p>

  <canvas id="curve"></canvas>
  <div>
    <label>line width </label>
    <input id="line-width" type="number" min="1" value="4" />
  </div>
  <script type="module" src="demo/curve.js"></script>

  <p></p>

  <h2>Color Gradients</h2>

  <p>
    To make fancier polygons, let's apply some color gradients! Suppose we want
    the color to transition from \(C_1\) to \(C_2\). We just need to take a
    weighted average $$interpolate(C_1, C_2, t) = (1-t) \cdot C_1 + t \cdot
    C_2$$ at each pixel, and vary the parameter \(t\) based on some kind of
    distance measurement. Take a look at the two types of color gradients below,
    computed as follows: $$RadialGradient(x,y) = interpolate\left(C_1, C_2,
    \frac{\sqrt{(x-x_o)^2 + (y-y_o)^2}}{r}\right)$$ $$LinearGradient(x,y) =
    interpolate\left(C_1, C_2, \frac{y - y_{min}}{y_{max} - y_{min}}\right)$$
  </p>

  <canvas id="gradient"></canvas>
  <div>
    <input id="gradient-color-1" type="color" value="#eeeeee" />
    <input id="gradient-color-2" type="color" value="#000000" />
  </div>
  <script type="module" src="./demo/gradient.js"></script>
  <p>
    Color gradient is an example of so-called
    <em>linear interpolation</em>.
  </p>

  <h2>Bézier Curves</h2>
  <p>
    We've seen that interpolating colors based on position produces color
    gradients. Interestingly, interpolating positions recursively based on a
    parameter shared by all levels of the recursion produces smooth curves
    &mdash; the ubiquitous
    <em>Bézier curves</em>.
  </p>
  <p>
    Bézier curves can be constructed iteratively using the
    <em>De Casteljau's algorithm</em>: Given control points \(p^{(0)}_0,
    p^{(0)}_1, \dots p^{(0)}_n\), we can find point \(B(t)\) on the curve in the
    following way:
  </p>
  <blockquote>
    <em
      >In each iteration \(k \in [1, n]\), for each \(i \in [0, n - k]\):
      $$p^{(k)}_i = (1-t) \cdot p^{(k-1)}_i + t \cdot p^{(k-1)}_{i+1}$$ Finally,
      \(B(t) := p^{(n)}_0\)</em
    >
  </blockquote>

  <p>
    Try clicking on the canvas below to stroke a Bézier curve (or any order).
    The color of the moving circle is linearly interpolated based on \(t\) as
    well.
  </p>

  <canvas id="animation"></canvas>
  <script type="module" src="./demo/animation.js"></script>

  <p>
    Now try creating some filled shapes made up of Bézier curves. (Note: after
    placing the starting point, you need to add \(N\) control points for each
    new Bézier segment of order \(N\), i.e., 2 for quadratic and 3 for cubic.)
  </p>

  <h4>Quadratic Bézier</h4>
  <canvas id="quadratic-bezier"></canvas>
  <h4>Cubic Bézier</h4>
  <canvas id="cubic-bezier"></canvas>

  <h2>Text</h2>
  <p>
    Why do we care about these weird shapes? As it turns out, every single
    character on this web page &mdash; or indeed, everything that uses
    OpenType/TrueType fonts &mdash; is made of nothing but linear (i.e. lines
    segments), quadratic and cubic Bézier curves!
  </p>
  <p>
    Take a look at the text below &mdash; it's being rendered by our
    implementatation of scan-line rasterization, the same one we used earlier to
    draw our first polygon!
  </p>
  <script type="module" src="./demo/bezier.js"></script>
  <canvas id="font"></canvas>
  <div>
    <label>font (OTF/TTF): </label>
    <input id="font-file" type="file" accept=".otf,.ttf" />
    <label>text </label>
    <input id="font-text" value="Everything is a polygon!" maxlength="30" />
    <label>size </label>
    <input id="font-size" type="number" step="1" value="40" />
  </div>
  <script type="module" src="./demo/font.js"></script>

  <h2>Layers</h2>
  <p>
    A GUI consists of a containment hierarchy of geometries, and when a
    containing geometry is transformed, the same transformation applies to
    everthing inside. This hierarchy is naturally represented as a tree.
  </p>
  <p>
    Visually, containers should lie beneath the things they contain, so nodes
    closer to the root must be drawn first. In other words, we need to perform a
    pre-order traversal:
  </p>
  <blockquote>
    <pre>
fn draw(node) {
  drawGeometry(node)
  for child in node.children {
    draw(child)
  }
}</pre
    >
  </blockquote>

  <p>
    For hit-testing, we need to identify the topmost polygon under the pointer.
    This is easy if we have recorded the polygons in the order they were drawn,
    in which case we could simply search through the records
    <em>backwards</em> for the last drawn polygon that contains the cursor
    position.
  </p>

  <p>
    Now you know how to roll your own <code>&lt;buton/&gt;</code>'s and
    <code>&lt;div/&gt;</code>'s!
  </p>

  <canvas id="recursion"></canvas>
  <div>
    <label>height </label>
    <input id="button-height" type="number" min="0" max="100" />
    <label>width </label>
    <input id="button-width" type="number" min="0" max="300" />
    <label>border radius </label>
    <input id="button-radius" type="number" min="0" max="100" />
  </div>
  <script type="module" src="./demo/composition.js"></script>

  <h2>Blending</h2>
  <p>
    If we want to see through the layers, we need to "blend" pixels from
    different layers. This is where the alpha channel (A) in RGBA comes in.
    There are many ways to add two colors together, one of which is the
    so-called "over" operator. Quite similar to what we did for color gradients
    and Bézier curves, the "over" operator computes a weighted average of two
    colors \((r_1, g_1, b_1, a_1)\) and \((r_2, g_2, b_2, a_2)\) based on their
    contributions to the final alpha value: $$ a = a_1 + a_2 (1-a_1)$$ $$(r,g,b)
    = \frac{a_1}{a}(r_1,g_1,b_1) + \frac{a_2(1-a_1)}{a}(r_2,g_2,b_2)$$
  </p>
  <canvas id="alpha-compositing"></canvas>
  <div>
    <label>alpha </label>
    <input id="alpha" type="number" min="0.1" max="1" value="0.2" step="0.1" />
  </div>
  <script type="module" src="./demo/alpha.js"></script>
  <p>
    But as you might have noticed, with only alpha blending, it's still quite
    difficult to tell the stacking order of the layers.
  </p>

  <h2>Filtering</h2>
  <p>
    One solution is to apply a "frosted glass" post-processing effect after
    blending. To do so, we need to "convolve" the image with a "kernel" &mdash;
    the word "convolution" might sound fancy, but it really is just a weighted
    average (yes, again) of the neighborhood surrounding each pixel, using the
    weights given by a "kernel" function \(G(u,v)\): $$C = \sum_{u=-k}^{k}
    \sum_{v=-k}^{k}G(u,v)$$ $$Output(x,y) = \frac{1}{C}\sum_{u=-k}^{k}
    \sum_{v=-k}^{k} G(u,v)Input(x-u, y-v).$$
  </p>
  <p>
    The kernel used for blurring is the 2D Gaussian function $$G(x,y) =
    \frac{1}{2\pi\sigma^2}\exp\left(-\frac{x^2+y^2}{2\sigma^2}\right),$$ and the
    result is the so-called <em>Gaussian blur</em>.
  </p>
  <p>
    Try dragging the lens below across the image to see Gaussian blur in action:
  </p>

  <canvas id="glass"></canvas>
  <div>
    <label>sigma </label>
    <input id="sigma" type="number" min="1" max="8" value="5" step="1" />
  </div>
  <script type="module" src="./demo/glass.js"></script>

  <h2>Acceleration</h2>
  <p>
    So far, we've been iterating through all pixels sequentially on the CPU for
    every single frame! This approach obvioiusly doesn't scale well with higher
    screen resolutions. Fortunately, for most of the steps above we can actually
    process all pixels
    <em>in parallel</em> &mdash; GPU to the rescue!
  </p>

  <canvas id="gpu"></canvas>
  <script type="module" src="./demo/gpu.js"></script>
</body>
