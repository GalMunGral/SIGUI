<head>
  <meta name="viewport" content="initial-scale=1, user-scalable=no" />
  <link
    href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400..800;1,400..800&display=swap"
    rel="stylesheet"
  />

  <style>
    body {
      max-width: 640px;
      padding: 40px;
      margin: auto;
      overflow-x: hidden;
      font-family: "EB Garamond", serif;
      font-size: 20px;
      padding-bottom: 200px;
    }

    code {
      font-size: 0.75em;
    }

    h1,
    h2,
    h3 {
      text-align: center;
      font-style: italic;
    }

    h2 {
      margin-top: 50px;
    }

    input {
      width: 200px;
    }

    input[type="number"] {
      width: 50px;
      margin-right: 10px;
    }

    label {
      color: gray;
      font-size: 0.75em;
    }

    input[type="file"] {
      width: 200px;
    }

    a {
      color: black;
    }

    pre {
      overflow: scroll;
    }

    canvas {
      user-select: none;
      display: block;
      width: 100%;
      height: 200px;
      box-shadow: 0 0 5px lightgray;
      margin: 20px auto;
      touch-action: none;
    }

    #gpu {
      box-shadow: none;
      height: 120px;
    }

    #glass {
      width: 600px;
      height: 400px;
    }

    blockquote pre {
      font-family: Courier, monospace;
      font-size: 16px;
    }
  </style>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script
    async
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"
  ></script>
</head>

<body>
  <h1>
    Structure and Interpretation<br />
    of Graphical User Interfaces
  </h1>

  <p>
    How do graphical user interfaces operate at the fundamental level of raw
    bytes and primitive operations (instructions)? How exactly does a computer,
    as its name implies,
    <em>compute</em> a (vector-based) graphical user interface into existence? How
    can things that feel alive arise from boring arithmetic and logical
    operations?
  </p>
  <p>
    This (incomplete) article is my first attempt to consolidate the pieces of
    information I've gathered over the years into a concise and coherent answer
    to these questions. In writing and sharing this article, my hope is to
    illuminate this relatively obscure area for those seeking insight, as I once
    was.
  </p>

  <h2>Event Loop</h2>

  <p>
    Interactive program are driven by event loops. For user interfaces, this is
    simply:
  </p>

  <blockquote>
    <pre>
  while !quit {
    if event = poll() {
      handle(event)
    }
    if dirty { 
      draw()
    }
  }</pre
    >
  </blockquote>
  <p>The program rapidly switches between these two steps until exit:</p>
  <blockquote>
    <pre>
fn draw() {
  for (x,y) in shape {
    color(x, y)
  }
}

fn handle(event) {
  target = pick(event.x, event.y)
  target.handle(e)
}</pre
    >
  </blockquote>
  <p>
    Try clicking on this canvas. Can you see the ghost emerging out of the
    noise?
  </p>

  <div style="position: relative">
    <canvas id="raster"></canvas>
  </div>
  <script type="module" src="./demo/raster.js"></script>

  <h2>Shapes</h2>
  <p>We all know how to draw a rectangle with a simple nested loop:</p>
  <blockquote>
    <pre>
for y in y1...y2 {
  for x in x1...x2 {
    color(x, y)
  }
} </pre
    >
  </blockquote>
  <p>
    This idea can be generalized to all closed shapes, except that for each
    \(y\) the horizontal scan line could now enter and leave the shape any
    number of times. Suppose it crosses the boundary at \(x_1, x_2, ...x_n\). It
    can be proved that \(n\) must be even, so all we need to do is to traverse
    the intervals \([x_1, x_2), [x_3, x_4), \dots, [x_{n-1}, x_n)\). In other
    words,
  </p>
  <blockquote>
    <pre>
for y in y1...y2 {
  for (x1, x2) in intervals(y) {
    for x in x1...x2 {
      color(x, y)
    }
  }
}</pre
    >
  </blockquote>
  <p>
    Using the same logic, we can check if a point at integer coordinates
    \((x,y)\) lies within a closed shape. If it does, \(x\) must be in the
    middle of one of the horizontal <code>intervals(y)</code>, and therefore
    there must be an odd number of intersections on either side &mdash; this is
    all we need for a hit-test!
  </p>
  <blockquote>
    <em>
      Given a point \((x_p,y_p)\), count the number of times the scan line \(y =
      y_p\) intersects the boundary at a \(x > x_p\) (or equivalently, \(x \leq
      x_p\)). The point is inside the boundary if and only if the number is odd.
    </em>
  </blockquote>
  But how do we find those intersection points?

  <h2>Polygons</h2>

  <p>
    One possible way is to approximate arbitrary shapes with polygons, so the
    task now becomes finding line segments that cross the scan line. Suppose a
    line segment has two endpoints \((x_1,y_1)\) (inclusive) and \((x_2, y_2)\)
    (exclusive), where \(y_1 < y_2\). We know a scan line \(y\) can only cross
    the line segment if \(y_1 \leq y < y_2\), and also $$intersection=\left(x_1
    + \frac{x_2-x_1}{y_2-y_1}(y-y_1), y\right).$$ The slope of line segment
    $$k=\frac{x_2-x_1}{y_2-y_1}$$ tells us the how much \(x\) changes when we
    increment \(y\). Using the slope we can jump along the line segment:
    \((x,y), (x+k, y+1), (x + 2k, y+2), \dots\)
  </p>
  <p>Here is the scan-line rasterization algorithm:</p>
  <blockquote>
    <em
      >Keep track of the set of edges that intersect the scan line along with
      their respective intersection points. In each iteration:
      <ol>
        <li>Traverse each horizontal interval at current \(y\).</li>
        <li>Increment \(y\), then</li>
        <ul>
          <li>Discard edges that no longer intersect the scan line.</li>
          <li>Increment each remaining intersection point by \((k, 1)\).</li>
          <li>Add new edges that begin to intersect the scan line.</li>
        </ul>
      </ol>
    </em>
  </blockquote>
  <p>
    The canvas below will draw a polygon from the points you click on, using a
    JavaScript implementation of this algorithm. (You must pick at least 3
    points to draw a polygon!) The polygon will light up in red when you hover
    over it.
  </p>

  <canvas id="polygon"></canvas>
  <script type="module" src="./demo/polygon.js"></script>

  <h2>Transforms</h2>
  <p>
    To move and morph our polygon, we need to apply linear transformations.
    Since a polygon is defined by its vertices, we just need to apply the same
    transformations to each vertex before we rasterize.
  </p>
  <p>
    Mathematically, it's more convenient to use homogeneous coordinates \((wx,
    wy, w)\) to represent a point \((x,y)\) on screen, because it turns
    translation, rotation and scaling all into composable \(3\times3\) matrices:
    $$T_{x,y} = \begin{pmatrix} 1 & 0 & x \\ 0 & 1 & y \\ 0 & 0 & 1
    \end{pmatrix},\ R_{\theta} = \begin{pmatrix} \cos\theta & -\sin\theta & 0 \\
    \sin\theta & \cos\theta & 0 \\ 0 & 0 & 1 \end{pmatrix},\ S_{c} =
    \begin{pmatrix} c & 0 & 0 \\ 0 & c & 0 \\ 0 & 0 & 1 \end{pmatrix}$$ Try
    dragging the square below to see the transforms in action:
  </p>

  <canvas id="transform"></canvas>
  <script type="module" src="./demo/transform.js"></script>

  <h2>Curves (I)</h2>
  <p>
    By sampling discrete points \(p_1, p_2, ...p_N\) along a curve, we can turn
    any shape into a polygon. When the sampling becomes so fine-grained that the
    line segments become subpixel, a polyline would be indistinguishable from a
    smooth curve.
  </p>
  <p>
    Let's take elliptic arcs as an eample. Suppose we want to draw an arc from
    angle \(\phi_1\) to \(\phi_2\) on a ellipse centered at \((x,y)\) with
    semi-major axis \(a\) and semi-minor axis \(b\) and rotated by an angle
    \(\theta\). We can sample \(N + 1\) points using the formula:
    $$\begin{pmatrix}x_i\\y_i\end{pmatrix} = T_{x,y} \cdot R_{\theta} \cdot
    \left(a\cos\left(\phi_1 + i \cdot\frac{\phi_2 - \phi_1}{N}\right),
    b\sin\left(\phi_1 + i\cdot\frac{\phi_2 - \phi_1}{N}\right)\right)^\top$$
  </p>
  <p>
    Try increasing \(N\) below to see how a polygon turns into a smooth shape.
  </p>

  <canvas id="ellipse"></canvas>
  <div>
    <label>\(N\)</label>
    <input id="ellipse-n" type="number" value="8" min="3" />
    <label>\(a\)</label> <input id="ellipse-a" type="number" value="150" />
    <label>\(b\)</label> <input id="ellipse-b" type="number" value="150" />
    <label>\(\theta\)</label>
    <input id="ellipse-theta" type="number" value="0" />
    <label>\(\phi_1\)</label>
    <input id="ellipse-phi-1" type="number" value="15" />
    <label>\(\phi_2\)</label>
    <input id="ellipse-phi-2" type="number" value="345" />
  </div>
  <script type="module" src="./demo/ellipse.js"></script>

  <h2>Curves (II)</h2>
  <p>
    Ellipses are not just interesting in their own right: We can actually draw
    thick curves as a sequences of skinny rectangles joined by circles, which
    are essentially a special case of ellipses.
  </p>
  <p>
    Try drawing on the canvas below. Have you noticed the circles and
    rectangles? What about when you increase the stroke width?
  </p>

  <canvas id="curve"></canvas>
  <div>
    <label>line width </label>
    <input id="line-width" type="number" min="1" value="4" />
  </div>
  <script type="module" src="demo/curve.js"></script>

  <p></p>

  <h2>Gradients</h2>

  <p>
    To make our polygons slightly more interesting, let's create some color
    gradients using a little bit of algebra. Suppose we want the color to
    transition from \(C_1\) to \(C_2\). We just need to take weighted averages
    $$interpolate(C_1, C_2, t) = (1-t) \cdot C_1 + t \cdot C_2$$ at each pixel,
    and vary the parameter \(t\) based on some kind of distance. Take a look at
    the two types of color gradients below, computed as follows:
    $$RadialGradient(x,y) = interpolate\left(C_1, C_2, \frac{\sqrt{(x-x_o)^2 +
    (y-y_o)^2}}{r}\right)$$ $$LinearGradient(x,y) = interpolate\left(C_1, C_2,
    \frac{y - y_{min}}{y_{max} - y_{min}}\right)$$
  </p>

  <canvas id="gradient"></canvas>
  <div>
    <input id="gradient-color-1" type="color" value="#eeeeee" />
    <input id="gradient-color-2" type="color" value="#000000" />
  </div>
  <script type="module" src="./demo/gradient.js"></script>
  <p>
    Gradients are just one example of what's called
    <em>linear interpolation</em>.
  </p>

  <h2>Bézier (I)</h2>
  <p>
    We've seen that interpolating colors based on position produces color
    gradients. Interestingly, interpolating positions (recursively) based on a
    "time" parameter produces smooth curves &mdash; the famous
    <em>Bézier curves</em>.
  </p>
  <p>
    Bézier curves can be constructed iteratively using the
    <em>De Casteljau's algorithm</em>: Given control points \(p^{(0)}_0,
    p^{(0)}_1, \dots p^{(0)}_n\), we can find point \(B(t)\) on the curve in the
    following way:
  </p>
  <blockquote>
    <em
      >In each iteration \(k \in [1, n]\), for each \(i \in [0, n - k]\):
      $$p^{(k)}_i = (1-t) \cdot p^{(k-1)}_i + t \cdot p^{(k-1)}_{i+1}$$ Finally,
      \(B(t) := p^{(n)}_0\)</em
    >
  </blockquote>

  <p>
    Try clicking on the canvas below to generate a Bézier curve of any order.
    The color of the moving circle is also linearly interpolated based on
    "time".
  </p>

  <canvas id="animation"></canvas>
  <script type="module" src="./demo/animation.js"></script>

  <h2>Bézier (II)</h2>
  <p>
    To rasterize a region enclosed by Bézier curves, we can apply the same trick
    we used before for elliptic arcs &mdash; just sample a few points and
    rasterize a polygon instead.
  </p>
  <p>
    Try creating some Bézier shapes below. Note that after placing the starting
    point, you need to add \(N\) control points for each new "Bézier edge" of
    order \(N\), i.e., 2 for quadratic and 3 for cubic.
  </p>

  <h4>Quadratic Bézier</h4>
  <canvas id="quadratic-bezier"></canvas>
  <h4>Cubic Bézier</h4>
  <canvas id="cubic-bezier"></canvas>

  <h2>Text</h2>
  <p>
    What are these weird shapes good for? As it turns out, every single
    character on this page &mdash; or indeed, everything that uses
    OpenType/TrueType fonts &mdash; is made of nothing but linear (i.e. lines
    segments), quadratic and cubic Bézier curves!
  </p>
  <p>
    Take a look at the text below &mdash; it's produced by the exact same
    JavaScript implementatation of scan-line rasterization that we used earlier
    to draw our first polygon!
  </p>
  <script type="module" src="./demo/bezier.js"></script>
  <canvas id="font"></canvas>
  <div>
    <label>font (OTF/TTF): </label>
    <input id="font-file" type="file" accept=".otf,.ttf" />
    <label>text </label>
    <input id="font-text" value="Everything is a polygon!" maxlength="30" />
    <label>size </label>
    <input id="font-size" type="number" step="1" value="40" />
  </div>
  <script type="module" src="./demo/font.js"></script>

  <h2>Layers</h2>
  <p>
    Elements on screen form a hierarchy &mdash; shapes contain other shapes, and
    when a containing shape moves, everthing inside moves along with it. This
    hierarchical relationship is best represented as a tree.
  </p>
  <p>
    Because containers typically lie underneath the things they contain, nodes
    higher up (reminder: it's upside-down) in the tree must be drawn first,
    which means we need to perform a pre-order traversal:
  </p>
  <blockquote>
    <pre>
fn draw(node) {
  drawGeometry(node)
  for child in node.children {
    draw(child)
  }
}</pre
    >
  </blockquote>

  <p>
    For hit-testing, we need to identify the topmost polygon under the pointer.
    This is easy if we've recorded polygons in the order they were drawn, as we
    could simply search through the records <em>backwards</em> for the
    <em>last</em> drawn polygon that contains the cursor position.
  </p>

  <p>
    Now you know how to roll your own <code>&lt;buton/&gt;</code>'s and
    <code>&lt;div/&gt;</code>'s!
  </p>

  <canvas id="recursion"></canvas>
  <div>
    <label>height </label>
    <input id="button-height" type="number" min="0" max="100" />
    <label>width </label>
    <input id="button-width" type="number" min="0" max="300" />
    <label>border radius </label>
    <input id="button-radius" type="number" min="0" max="100" />
  </div>
  <script type="module" src="./demo/composition.js"></script>

  <h2>Blending</h2>
  <p>
    What if we want to see through the layers? This is where the alpha channel
    (A) in RGBA comes in. There are many ways to blend two colors, one of which
    is the so-called "over" operator. Similar to color gradients and Bézier
    curves, the "over" operator computes a weighted average of the two colors
    \((r_1, g_1, b_1, a_1)\) and \((r_2, g_2, b_2, a_2)\) based on their
    contributions to the final alpha value: $$ a = a_1 + a_2 (1-a_1)$$ $$(r,g,b)
    = \frac{a_1}{a}(r_1,g_1,b_1) + \frac{a_2(1-a_1)}{a}(r_2,g_2,b_2)$$
  </p>
  <canvas id="alpha-compositing"></canvas>
  <div>
    <label>alpha </label>
    <input id="alpha" type="number" min="0.1" max="1" value="0.2" step="0.1" />
  </div>
  <script type="module" src="./demo/alpha.js"></script>
  <p>
    But this is not the end of the story: To stack transparent layers on top of
    each other, we need more than just alpha blending, otherwise it'd be
    difficult to tell which layer is on the top and which is on the bottom.
  </p>

  <h2>Filtering</h2>
  <p>
    One solution is to apply a "frosted glass" post-processing effect. To do
    this, we need to "convolve" the rasterized image. The word "convolution"
    might sound fancy, but it really is just a weighted average (yes, again) of
    the neighborhood around each pixel. Formally, with a "kernel" \(G(u,v)\):
    $$C = \sum_{u=-k}^{k} \sum_{v=-k}^{k}G(u,v)$$ $$Output(x,y) =
    \frac{1}{C}\sum_{u=-k}^{k} \sum_{v=-k}^{k} G(u,v)Input(x-u, y-v).$$
  </p>
  <p>
    The kernel used for blurring is usually the 2D Gaussian function $$G(x,y) =
    \frac{1}{2\pi\sigma^2}\exp\left(-\frac{x^2+y^2}{2\sigma^2}\right),$$ and the
    result is the so-called <em>Gaussian blur</em>.
  </p>
  <p>
    Try dragging the lens below across the image to see Gaussian blur in action:
  </p>

  <canvas id="glass"></canvas>
  <div>
    <label>sigma </label>
    <input id="sigma" type="number" min="1" max="8" value="5" step="1" />
  </div>
  <script type="module" src="./demo/glass.js"></script>

  <h2>Acceleration</h2>
  <p>
    So far, we've been tirelessly looping through all pixels on the CPU for
    every single frame! This approach obvioiusly doesn't scale well with higher
    screen resolutions. Fortunately, for most of the steps above we can actually
    process all pixels
    <em>in parallel</em> &mdash; GPU to the rescue!
  </p>

  <canvas id="gpu"></canvas>
  <script type="module" src="./demo/gpu.js"></script>
</body>
