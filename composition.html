<style>
  body {
    user-select: none;
    width: min(50vw, 600px);
    margin: 50px auto;
  }
  input[type="number"] {
    width: 50px;
  }
  canvas {
    width: min(50vw, 600px);
    height: 300px;
    border: 1px solid black;
  }
</style>

<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"
></script>

<h1>
  Structure and Interpretation of <br />
  User Interfaces
</h1>

<a href="./interpolation">prev</a>
<a href="./image">next</a>

<h2>4. Compositing and Composition</h2>
<h3>4.1. Alpha Compositing</h3>
<pre>
function putPixel(image, x, y, color) {
  const { data, width, height } = image;
  if (x < 0 || x >= width || y < 0 || y >= height) return;
  const base = (y * width + x) * 4;
  const [r2, g2, b2, a2] = scale([...data.slice(base, base + 4)], 1 / 255);
  const [r1, g1, b1, a1] = color;
  const a = a1 + a2 * (1 - a1);
  const [r, g, b] = add(
    scale([r1, g1, b1], a1 / a),
    scale([r2, g2, b2], (a2 * (1 - a1)) / a)
  );
  data[base] = Math.round(r * 255);
  data[base + 1] = Math.round(g * 255);
  data[base + 2] = Math.round(b * 255);
  data[base + 3] = Math.round(a * 255);
}
</pre>
<h3>4.2. Recursion</h3>
<p>
  Imagine we are trying to draw a button, which has a green background, rounded
  corners, a black shadow, and text in the center that says "button".
</p>
<pre>
class UIRenderer {
  pending = [];
  committed = [];
  
  constructor(canvas, root) {
    this.root = root;
    this.root.render(this);
    setup(
      canvas,
      (buffer) => {
        if (this.pending.length) {
          this.commit(buffer);
        }
      },
      {
        onClick: (p) => {
          const comp = this.hitTest(p);
          if (comp?.handleClick?.(p)) {
            this.root.render(this);
          }
        },
        onPointerDown: (p) => {
          const comp = this.hitTest(p);
          if (comp?.handlePointerDown?.(p)) {
            this.root.render(this);
          }
        },
        onPointerMove: (p) => {
          const comp = this.hitTest(p);
          if (comp?.handlePointerMove?.(p)) {
            this.root.render(this);
          }
        },
        onPointerUp: (p) => {
          const comp = this.hitTest(p);
          if (comp?.handlePointerUp?.(p)) {
            this.root.render(this);
          }
        },
      }
    );
  }
  
  hitTest(p) {
    for (const { component, polygon } of this.committed) {
      if (polygon.contains(p)) {
        return component;
      }
    }
  }
  
  render(component, polygon, color) {
    this.pending.push({ component, polygon, color });
  }
  
  commit(buffer) {
    buffer.clear();
    this.pending.forEach(({ polygon, color }) => {
      polygon.fill(buffer, color);
    });
    this.committed = this.pending.reverse();
    this.pending = [];
  }
}
  
</pre>
<div>
  <canvas id="recursion"></canvas>
</div>
<script type="module" src="./demo/composition.js"></script>
