<style>
  body {
    user-select: none;
    width: min(50vw, 600px);
    margin: 50px auto;
  }
  input[type="number"] {
    width: 50px;
  }
  canvas {
    width: min(50vw, 600px);
    height: 300px;
    border: 1px solid black;
  }
</style>

<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"
></script>

<h1>
  Structure and Interpretation of <br />
  User Interfaces
</h1>

<a href="./index">prev</a>
<a href="./interpolation">next</a>

<h2>1. Polygons</h2>

<h3>1.1. Polygon Rasterization</h3>
<em>Implementation:</em>
<pre>
function fillPolygon(image, vertices, color) {
  const edges = [];

  for (const i of vertices.keys()) {
    let [x1, y1] = vertices[i];
    let [x2, y2] = vertices[(i + 1) % vertices.length];
    if (y1 == y2) continue;
    if (y1 > y2) [x1, x2, y1, y2] = [x2, x1, y2, y1];
    // [min-y, max-y, min-x, dx/dy]
    edges.push([y1, y2, x1, (x2 - x1) / (y2 - y1)]);
  }

  if (!edges.length) return;

  // sort primarily by min-y, secondarily by min-x
  edges.sort((e1, e2) => (e1[0] == e2[0] ? e1[2] - e2[2] : e1[0] - e2[0]));

  // scan-line fill
  let y = Math.ceil(edges[0][0]) - 1;
  let active = [];

  do {
    for (let i = 0; i < active.length; i += 2) {
      for (let x = Math.ceil(active[i][1]); x < active[i + 1][1]; ++x) {
        putPixel(image, x, y, color(x, y));
      }
    }

    ++y;
    active = active.filter(([minY]) => minY > y);
    for (const edge of active) {
      edge[1] += edge[2];
    }
    while (edges.length && edges[0][0] <= y) {
      const [minY, maxY, minX, k] = edges.shift();
      // [max-y, intersection-x, k]
      active.push([maxY, minX + k * (y - minY), k]);
    }
    // sort by intersection-x
    active.sort((e1, e2) => e1[1] - e2[1]);
  } while (active.length || edges.length);
}  
</pre>

<h3>1.2. Polygon Hit-test</h3>
<p>
  An "inverse" problem of rasterization is hit-testing: Given a pixel on screen,
  can we infer which polygon it belongs to? We again employ the even-odd rule
  that we used for rasterization, i.e. a point lies in the polygon if a ray
  starting at the point intersects the polygon an odd number of times. To make
  the computation simpler we can simply shoot the ray in the \(+x\) direction.
</p>
<em>Implementation:</em>
<pre>
function hitTest([x, y], vertices) {
  let intersections = 0;
  for (const i of vertices.keys()) {
    let [x1, y1] = vertices[i];
    let [x2, y2] = vertices[(i + 1) % vertices.length];
    if (y1 > y2) [x1, x2, y1, y2] = [x2, x1, y2, y1];
    if (y1 <= y && y2 > y) {
      const intersectionX = x1 + ((x2 - x1) / (y2 - y1)) * (y - y1);
      if (intersectionX > x) {
        ++intersections;
      }
    }
  }
  return intersections & 1;
}
</pre>
<div>
  <canvas id="polygon"></canvas>
</div>
<div>
  <button id="polygon-clear">clear</button>
</div>
<script type="module" src="./demo/polygon.js"></script>

<h3>1.3. Linear Transformations</h3>
<p>
  To translate, rotate or scale a polygon, we can apply the transformation to
  each individual vertex before rasterization. If we use homogeneous coordinates
  \((x, y, 1)\) to represent a point \((x, y)\) in the 2D plane, these
  transformations can be expressed nicely as \(3\times3\) matrices:
</p>
<ul>
  <li>
    Translation: $$T_{x,y} = \begin{pmatrix} 1 & 0 & x \\ 0 & 1 & y \\ 0 & 0 & 1
    \end{pmatrix}$$
  </li>
  <li>
    Rotation: $$R_\theta = \begin{pmatrix} \cos\theta & -\sin\theta & 0 \\
    \sin\theta & \cos\theta & 0 \\ 0 & 0 & 1 \end{pmatrix}$$
  </li>
  <li>
    Scaling: $$S_c = \begin{pmatrix} c & 0 & 0 \\ 0 & c & 0 \\ 0 & 0 & 1
    \end{pmatrix}$$
  </li>
</ul>

<div>
  <canvas id="transform"></canvas>
</div>
<script type="module" src="./demo/transform.js"></script>

<h3>1.4. Parametric Curves</h3>
<p>
  Polygons are interesting because we can approximate any curve with a polygon
  by taking dicrete samples along the curve. If the number of samples is
  sufficiently large such that each segment becomes subpixel, the polygon would
  appear indistinguishable from the actual curve!
</p>
<p>
  Using what we have leared so far, we can now draw many more interesting
  shapes. For example, an elliptic arc from angle \(\phi_1\) to \(\phi_2\) on a
  ellipse centered at \((x,y)\), with semi-major axis \(a\) and semi-minor axis
  \(b\), and rotated by an angle \(\theta\), can be drawn as a polygon with \(N
  + 1\) vertices: $$(x_i, y_i) = T_{(x, y)} \cdot R_\theta \cdot
  \left(a\cos\left(\phi_1 + i \cdot\frac{\phi_2 - \phi_1}{N}\right),
  b\sin\left(\phi_1 + i\cdot\frac{\phi_2 - \phi_1}{N}\right)\right)$$
</p>
<em>Implementation</em>
<pre>
const vertices = [[cx, cy]];
for (let i = 0; i <= n; ++i) {
  vertices.push(
    compose(
      translate(cx, cy),
      rotate(theta)
    )([
      a * Math.cos(phi1 + (i * (phi2 - phi1)) / n),
      b * Math.sin(phi1 + (i * (phi2 - phi1)) / n),
    ])
  );
}
</pre>
<div>
  <canvas id="ellipse"></canvas>
</div>
<div>
  <label>\(N\):</label>
  <input id="ellipse-n" type="number" value="16" min="3" />
  <label>\(a\):</label> <input id="ellipse-a" type="number" value="200" />
  <label>\(b\):</label> <input id="ellipse-b" type="number" value="150" />
  <label>\(\theta\):</label>
  <input id="ellipse-theta" type="number" value="45" />
  <label>\(\phi_1\):</label>
  <input id="ellipse-phi-1" type="number" value="0" />
  <label>\(\phi_2\):</label>
  <input id="ellipse-phi-2" type="number" value="360" />
</div>
<script type="module" src="./demo/ellipse.js"></script>
